from filters import *


class Effect:
    '''\
        Represent the intention to modify the characteristics or controller of a
        dynamically determined set of game objects.
    '''
    def __init__(self, selection, **kwargs):
        self.components = list([])
        self._selection = selection
        self.selectable_objects_cache = None
        self.locked = False
        self.unlockable = True
        self.expired = False

        # Support subclassing.
        for kwarg in kwargs:
            setattr(self, kwarg, kwargs[kwarg])

    @property
    def selectable_objects(self):
        if (self.selectable_objects_cache is None):
            self.selectable_objects_cache = self._selection.selectable_objects(as_list=True)
        return self.selectable_objects_cache

    def refresh_selectable_objects_cache(self):
        if not(self.locked):
            self.selectable_objects_cache = None

    def unlock(self):
        if self.unlockable:
            self.locked = False


class ContinuousEffect(Effect):
    def __init__(self, selection, timestamp, duration, **kwargs):
        self.timestamp = timestamp
        self.duration = duration
        super().__init__(selection=selection, **kwargs)


class ContinuousEffectViaResolution(ContinuousEffect):
    '''\
        611.2a  A continuous effect generated by the resolution of a spell or ability lasts as long as
                stated by the spell or ability creating it (such as "until end of turn"). If no duration
                is stated, it lasts until the end of the game.

        611.2c  If a continuous effect generated by the resolution of a spell or ability modifies the
                characteristics or changes the controller of any objects, the set of objects it affects
                is determined when that continuous effect begins. After that point, the set won't change.
                A continuous effect generated by the resolution of a spell or ability that doesn't modify
                the characteristics or change the controller of any objects modifies the rules of the game,
                so it can affect objects that weren't affected when the continuous effect began.
                If a single continuous effect has parts that modify the characteristics or changes the
                controller of any objects and other parts that don't, the set of objects each part applies
                to is determined independently.

        611.2d  If a resolving spell or ability that creates a continuous effect contains a variable such as X,
                the value of that variable is determined only once, on resolution (See: 608.2g).

        613.7b  A continuous effect generated by the resolution of a spell or ability receives a timestamp
                at the time it is created.
    '''
    def __init__(self, selection, timestamp, duration=None, **kwargs):
        super().__init__(selection=selection, timestamp=timestamp, duration=duration, **kwargs)
        # NOTE #
        # Key distinctions:
        # [1] Not unlockable
        self.unlockable = False
        # [2] Selection is solved and locked in at instantiation
        self.selectable_objects_cache = self._selection.selectable_objects(as_list=True)
        # [3] Record the temp_ids of the original set of affected objects
        self.original_temp_ids = {object.temp_id for object in self.selectable_objects_cache}

    @property
    def set_of_affected_objects(self):
        '''\
            Affect only objects from the original set of affected objects which are either players,
            or game objects which are phased in and which have the same temporary id (indicating they
            haven't become new objects due to zone changes since the set was determined).
        '''
        return filter(lambda x: ((x.temp_id in self.original_temp_ids) and ((isinstance(x, Modifiable) and not(x.is_phased_out)) or isinstance(x, ExpandedPlayerObject))), self.selectable_objects)

    @property
    def is_valid(self):
        return not(self.expired)



class ContinuousEffectViaStaticAbility(ContinuousEffect):
    '''\
        611.3a  A continuous effect generated by a static ability isn't "locked in"; it applies at any given
                moment to whatever its text indicates.

        611.3b  The effect applies at all times that the permanent generating it is on the battlefield or
                the object generating it is in the appropriate zone.
        
        611.3c  Continuous effects that modify characteristics of permanents do so simultaneously with the
                permanent entering the battlefield. They don't wait until the permanent is on the battlefield
                and then change it. Because such effects apply as the permanent enters the battlefield, they
                are applied before determining whether the permanent will cause an ability to trigger when it
                enters the battlefield.

        613.7a  A continuous effect generated by a static ability has the same timestamp as the object the
                static ability is on, or the timestamp of the effect that created the ability, whichever is
                later.

        
    '''
    def __init__(self, selection, timestamp, duration=None, **kwargs):
        super().__init__(selection=selection, timestamp=timestamp, duration=duration, **kwargs)

    @property
    def set_of_affected_objects(self):
        '''\
            Ensure objects which are phased out but otherwise fall into this effect's selected
            objects do not get affected.
        '''
        return filter(lambda object: (isinstance(object, ExpandedPlayerObject) or not(object.is_phased_out)), self.selectable_objects)


class ContinuousEffectGenerator:
    '''\
        611.2
        A continuous effect may be generated by the resolution of a spell or ability.
        611.3
        A continuous effect may be generated by the static ability of an object.

        This class encapsulates the data and operations that are shared by generators
        of continuous effects.

        It represents the data necessary for generating continuous effects including
            references to the object hosting this ability;
            rules for determining which objects should be modified; and,
            the nature of the modifications entailed by each part of the effect to generate.

        The dynamic approach is motivated in part by the need to copy effect generators
        without copying the references the original effect generator depended on.
    '''
    def __init__(self,
                 effect_type,
                 host_object,
                 external_predicates,
                 phi_factories,
                 player_phi_factories,
                 components):
        '''\
            # NOTE #
            All arguments that are lists are copied when assigned during initialization,
            guaranteeing that references aren't jumbled up by clone_for_new_host_object.
        '''
        self.effect_type = effect_type
        self.host_object = host_object
        self.external_predicates = list(external_predicates)
        self.phi_factories = list(phi_factories)
        self.player_phi_factories = list(player_phi_factories)
        self.dependent_predicates = [phi_factory(self) for phi_factory in phi_factories]
        self.player_predicates = [player_phi_factory(self) for player_phi_factory in player_phi_factories]
        self.components = list(components)
        self.object_id = id(self)
        self.true_id = uuid.uuid4().hex

    def generate_effect_predicate(self):
        '''\
            Compose the dependent and external predicates that will define the
            set of game objects to affect and/or compose the predicates that will define the
            set of player objects to affect. In the event both predicate compositions exist,
            create a disjunction of conjunctions.
        '''
        # Case # Selection only pertains to game objects.
        if not(self.player_predicates):
            return CONJ(FIND.game_object_identity, *self.dependent_predicates, *self.external_predicates)

        # Case # Selection only pertains to player objects.
        elif (not(self.external_predicates) and not(self.dependent_predicates)):
            return CONJ(FIND.player_object_identity, *self.player_predicates)

        # Case # Selection pertains to player objects or game objects.
        else:
            return DISJ(CONJ(FIND.player_object_identity, *self.player_predicates),
                        CONJ(FIND.game_object_identity, *self.dependent_predicates, *self.external_predicates))

    @property
    def antecedents_verified(self):
        # NOTE # Over-ride this property in static abilities with a custom condition.
        return True

    def generate_effect_(self):
        '''\
            Subclass-specific auxillary method.
        '''
        raise NotImplementedError("Must be over-ridden by subclasses.")

    def generate_effect(self):
        '''\
            Generate the effect in the manner defined by the subclass-specific generate_effect_()
            method, then generate and supply each of its components, synchronizing their references
            and forcing them to generate their intended modifications now that such references are
            guaranteed to be correct.
        '''
        effect = self.generate_effect_()
        for component in self.components:
            component.reference_effect = effect
            # EffectComponents need a generate_deltas() call once their references are synced.
            component.generate_deltas()
            effect.components.append(component)
        return effect

    def clone_for_new_host_object(self, new_host_object):
        raise NotImplementedError("Must be over-ridden by subclasses.")

    def __repr__(self):
        return "|{}|{}|".format(self.true_id, self.debug_string)

    def __eq__(self, instance):
        if isinstance(instance, ContinuousEffectGenerator):
            return self.true_id == instance.true_id
        return False


class ResolutionContinuousEffectGenerator(ContinuousEffectGenerator):
    '''\
        Subclass of ContinuousEffectGenerator which extends the logic to include
        dynamic generation and proper copying of durations, which apply to continuous
        effects generated by the resolution of spells or abilities (and do not apply
        to continuous effects generated by static abilities).
    '''
    def __init__(self,
                 host_object,
                 external_predicates,
                 phi_factories,
                 player_phi_factories,
                 components,
                 duration=None):
        self.duration = duration
        super().__init__(effect_type=ContinuousEffectViaResolution,
                         host_object=host_object,
                         external_predicates=external_predicates,
                         phi_factories=phi_factories,
                         player_phi_factories=player_phi_factories,
                         components=components)

    def generate_duration(self):
        ''' Copy the reference instance. Only called if self.duration is not None. '''
        return self.duration.clone()

    def generate_effect_(self):
        '''\
            613.7b
            A continuous effect generated by the resolution of a spell or ability
            receives a timestamp at the time it is created.
        '''
        effect = self.effect_type(selection=EffectSelection(self.generate_effect_predicate()),
                                  timestamp=TIMESTAMP())
        effect.reference_ability = self

        if (self.duration is not None):
            duration = self.generate_duration()
            duration.update_reference_effect(effect)
            effect.duration = duration
        else:
            effect.duration = None

        return effect

    def generate_effect(self):
        return super().generate_effect()

    def clone_for_new_host_object(self, new_host_object):
        return self.__class__(host_object=new_host_object)


#########
# ALIAS #
#########
ResContFXGen = ResolutionContinuousEffectGenerator

class StaticAbility(ContinuousEffectGenerator):
    '''\
        Subclass of ContinuousEffectGenerator which extends the logic to include
        information about whether the static ability should generate the effect or
        not on the basis of the location of its host object relative to the zones
        within which this ability is active.
    '''
    def __init__(self,
                 host_object,
                 external_predicates,
                 phi_factories,
                 player_phi_factories,
                 components,
                 active_zone_types=[Battlefield]):
        # Differentiate between abilities which are derived from rules text and are intrinsic
        # to the game objects hosting subclass instances, vs. those that are granted by effects.
        self.origin = "rules_text"
        self.active_zone_types = list(active_zone_types)
        super().__init__(effect_type=ContinuousEffectViaStaticAbility,
                         host_object=host_object,
                         external_predicates=external_predicates,
                         phi_factories=phi_factories,
                         player_phi_factories=player_phi_factories,
                         components=components)

    @property
    def is_cda(self):
        # CDA are active everywhere; CDA use active_zone_types := [None] as a convention to
        # control this. Whether an ability is a CDA can therefore be inferred from its
        # active_zone_types attribute rather than from an inspection of its components.
        return (None in self.active_zone_types)

    @property
    def cda_attributes(self):
        if self.is_cda:
            result = []
            for component in self.components:
                if component.is_cda:
                    for delta in component.deltas:
                        result.extend(delta.reference_attributes)
            return set(result)
        return set([])

    @property
    def is_active(self):
        # Case: CDA which is active regardless of where the host object is.
        if (None in self.active_zone_types):
            return True
        # Case: Not a CDA.
        host_object_current_zone = self.host_object.current_zone
        return any(isinstance(host_object_current_zone, active_zone_type) for active_zone_type in self.active_zone_types)

    @property
    def timestamp(self):
        return self.host_object.timestamp

    def generate_effect_(self):
        effect = self.effect_type(selection=EffectSelection(self.generate_effect_predicate()),
                                  timestamp=self.timestamp)
        effect.reference_ability = self
        return effect

    def generate_effect(self):
        return super().generate_effect()

    def clone_for_new_host_object(self, new_host_object):
        result = self.__class__(host_object=new_host_object)
        # Distinguish abilities granted by copiable effects
        result.origin = "copiable_effect"
        return result


class MarkerEffectComponent:
    def __init__(self, layer, external_deltas, reference_marker=None):
        self.layer = layer
        self.deltas = list(external_deltas)
        self.reference_marker = reference_marker
        # Attributes for compatibility with standard effect components and expectations
        # in EffectHandler regarding attributes.
        self.is_cda = False
        self.relative_component_ordinal = 0
        self.valid = True
        self.object_id = id(self)
        self.is_marker_effect_component = True

    @property
    def timestamp(self):
        return self.reference_marker.timestamp

    def enact(self, lock=False):
        '''\
            Match signature of EffectComponent.enact method, although the lock argument isn't used here.
        '''
        object_to_affect = self.reference_marker.host_object
        for delta in self.deltas:
            new_value = delta.compute(ref_obj=object_to_affect)
            for reference_attribute in delta.reference_attributes:
                setattr(object_to_affect, reference_attribute, new_value)

# Alias #
MFXC = MarkerEffectComponent


class EffectComponent:
    '''\
        ----------------------------------------------------------------------------------------
        613.6
            If an effect should be applied in different layers and/or sublayers, the parts
        of the effect each apply in their appropriate ones. If an effect starts to apply in
        one layer and/or sublayer, it will continue to be applied to the same set of objects in
        each other applicable layer and/or sublayer, even if the ability generating the effect is
        removed during this process.
        ----------------------------------------------------------------------------------------

        Some continuous effects represent the intention to temporarily modify the characteristics or controller
        of game objects. The intended modifications can be decomposed into separate components according to the
        layer system governing the interaction of continuous effects.
        
        The EffectComponents which constitute such a continuous effect contain the data necessary for the layer
        system to apply them in the correct order. Data that is shared across components can be accessed through
        references to the superordinate effect.

        When the nature of the intended modification varies as a function of the properties of related abilities
        or objects, instantiation of the Deltas which encode the modification must wait for references to be
        provided. An EffectComponent's Deltas are therefore generated dynamically immediately prior to enacting
        the intended modification.

    '''
    def __init__(self, layer, external_deltas, delta_factories=[], is_cda=False, reference_effect=None):
        self.layer = layer
        self.external_deltas = external_deltas
        self.delta_factories = delta_factories
        self.deltas = []
        self.is_cda = is_cda
        self.reference_effect = reference_effect
        self.object_id = id(self)
        self.is_marker_effect_component = False

    def clone(self):
        result = EffectComponent(layer=self.layer,
                                 external_deltas=list(self.external_deltas),
                                 delta_factories=list(self.delta_factories),
                                 is_cda=self.is_cda)
        result.deltas = list([])
        return result

    def generate_deltas(self):
        '''\
            Dynamically generate the Deltas which encode the intended modifications to game objects.
            This method is called only when all of the references upon which their definition might
            depend are guaranteed to be correct.
        '''
        self.deltas = self.external_deltas + [delta_factory(self) for delta_factory in self.delta_factories]

    @property
    def host_object(self):
        return self.reference_effect.reference_ability.host_object

    @property
    def timestamp(self):
        return self.reference_effect.timestamp

    @property
    def relative_component_ordinal(self):
        '''\
            Ensures that components of the same effect which apply in the same (sub)layer are applied
            in the correct relative order, example:
            Dance of the Skywise
                ... loses all abilities, and gains flying ...
        '''
        return self.reference_effect.components.index(self)

    @property
    def set_of_affected_objects(self):
        return self.reference_effect.set_of_affected_objects

    @property
    def generator_exists(self):
        return self.reference_effect.reference_ability in self.host_object.abilities

    @property
    def first_component(self):
        return not(self.relative_component_ordinal)

    @property
    def generator_static(self):
        return isinstance(self.reference_effect, ContinuousEffectViaStaticAbility)

    @property
    def valid(self):
        '''\
            Only Components which are the first component of an Effect generated by a StaticAbility
            which no longer exists are invalid. Supports detecting when applying one component
            causes the second component to exist, while allowing multi-component effects which begin
            to apply prior to being removed to continue applying all of their components even after
            being removed.
        '''
        return not((self.first_component and self.generator_static) and not(self.generator_exists))

    def enact(self, lock=False):
        '''\
            Modify each of the game objects our superordinate Effect dictates should
            be modified in the manner described by our Deltas. Locking our superordinate
            Effect ensures that Rule 613.6 is obeyed in cases where Effects with multiple
            components do not have all of their components applied, because a component in
            an earlier layer modified objects such that they no longer match the Effect's
            predicate.

            Example
            An effect that reads "All noncreature artifacts become 2/2 artifact creatures
            until end of turn" is both a type-changing effect and a power-and-toughness-setting
            effect. The type-changing effect is applied to all noncreature artifacts in layer 4
            and the power-and-toughness-setting effect is applied to those same permanents in
            layer 7b, even though those permanents aren't noncreature artifacts by then.
        '''
        if lock:
            self.reference_effect.locked = True

        if self.reference_effect.reference_ability.antecedents_verified:
            for affected_object in self.set_of_affected_objects:
                for delta in self.deltas:
                    new_value = delta.compute(ref_obj=affected_object)
                    for reference_attribute in delta.reference_attributes:
                        setattr(affected_object, reference_attribute, new_value)


# Alias #
FXC = EffectComponent



class CopyEffectComponent(EffectComponent):
    '''\
        Subclass of EffectComponent which supports copy effects.
    '''
    def __init__(self, modifications=[], ignore=[], reference_effect=None):
        self.modifications = list(modifications)
        self.ignore = list(ignore)
        self.deltas_fixed = False
        super().__init__(layer='1a',
                         external_deltas=[],
                         delta_factories=[],
                         is_cda=False,
                         reference_effect=reference_effect)

    def clone(self):
        result = CopyEffectComponent(modifications=list(self.modifications),
                                     ignore=list(self.ignore))
        result.reference_effect = None
        result.deltas_fixed = False
        result.deltas = list([])
        return result

    @property
    def copy_source_object(self):
        return self.host_object.copy_source_object

    @property
    def characteristics_with_specified_values(self):
        '''\
            Used to determine if there are CDA of the copy source object which
            shouldn't be copied (see 707.9d).
        '''
        result = list(self.ignore)
        for modification in self.modifications:
            result.extend(modification.reference_attributes)
        return set(result)

    def skip_copy_test(self, charx_with_specified_values, ability):
        '''\
            Determine whether an ability should be copied
        '''
        if ability.is_cda:
            # NOTE #
            # cda_attributes is a non-empty set if ability.is_cda, so subset test works.
            # reminder, < is the test for a proper subset.
            if (ability.cda_attributes <= charx_with_specified_values):
                return True
        return False

    def generate_deltas(self):
        '''\
            Create a list of Deltas, each responsible for modifying the characteristic
            associated with each of the copiable values of the copy source object.
            When copying the abilities characteristic, use the special case AbilitiesK
            subclass, so that elements of the list which are ContinuousEffectGenerators
            in the form of StaticAbility instances are cloned in a manner that respects
            references.

            707.2b Once an object has been copied, changing the copiable values of the original
            object won't cause the copy to change.

            707.2c If a static ability generates a continuous effect that's a copy effect, the
            copiable values that effect grants are determined only at the time that effect first
            starts to apply.

            These rules both imply that the extracted values should be deep copied so that changes
            in the source cannot affect the copier object's appearance; and, that deltas only need
            to be generated once before fixing them.
        '''
        if not(self.deltas_fixed):
            if (self.copy_source_object is not None):
                copy_deltas = []
                source_object_copiable_values = deepcopy(self.copy_source_object.copiable_values)
                for attribute in source_object_copiable_values:
                    if not(attribute in self.ignore):
                        if not(attribute == 'abilities'):
                            copy_deltas.append(K(reference_attributes=[attribute],
                                                 constant_value=copy_sensitive(source_object_copiable_values[attribute])))
                        else:
                            charx_with_specified_values = self.characteristics_with_specified_values
                            abilities_to_add = []
                            abilities_to_copy = source_object_copiable_values[attribute]
                            # Case: No need to worry about skipping certain CDA.
                            if not(charx_with_specified_values):
                                abilities_to_add = abilities_to_copy

                            # Case: Might need to skip certain CDA.
                            else:
                                for ability in abilities_to_copy:
                                    if not(self.skip_copy_test(charx_with_specified_values, ability)):
                                        abilities_to_add.append(ability)

                            copy_deltas.append(AbilitiesK(reference_attributes=[attribute],
                                                          constant_value=abilities_to_add))

                self.deltas = copy_deltas + self.modifications
            else:
                self.deltas = []
            self.deltas_fixed = True



class FaceDownEffectComponent(EffectComponent):
    '''\
        Special case of EffectComponent for generating the characteristic modifications
        implied by the physical status of being face down.
    '''
    default_facedown_attributes = [
        ('impl_name', ''),
        ('mana_cost', ''),
        ('card_types', set(['creature'])),
        ('subtypes', set([])),
        ('supertypes', set([])),
        ('power', 2),
        ('toughness', 2),
        ('loyalty', 0),
        ('color', set(['colorless'])),
        ('abilities', list([]))
    ]

    def __init__(self, external_deltas=[]):
        # External deltas allow for customizing these effects in case they specify
        # different face-down characteristics than the default embodied by instances
        # of this type of EffectComponent.
        self.deltas_fixed = False
        super().__init__(layer='1b',
                         external_deltas=list(external_deltas),
                         delta_factories=[],
                         is_cda=False,
                         reference_effect=None)

    def clone(self):
        return FaceDownEffectComponent(external_deltas=list(self.external_deltas))

    def generate_deltas(self):
        '''\
            Generate the layer 1b modifications to characteristics entailed by the physical
            status of being face down.
        '''
        if not(self.deltas_fixed):
            facedown_deltas = []
            for item in self.default_facedown_attributes:
                delta = K(reference_attributes=[item[0]],
                          constant_value=item[1])
                facedown_deltas.append(delta)
            self.deltas = facedown_deltas + self.external_deltas
            self.deltas_fixed = True


class KeywordAbility:
    '''\
        Represent keyword abilities like flying, trample, etc.
    '''
    def __init__(self, host_object, ability_name, origin='rules_text'):
        self.host_object = host_object
        self.ability_name = ability_name
        self.origin = origin

    def __eq__(self, object):
        return (isinstance(object, KeywordAbility) and (self.ability_name == object.ability_name))

    def clone_for_new_host_object(self, new_host_object):
        return self.__class__(host_object=new_host_object)

    def __repr__(self):
        return "|KWA|{}|".format(self.ability_name.title())

KWA = KeywordAbility


class KWAProhibition:
    '''\
        Used to record information prohibiting effects that would otherwise grant KWA to certain objects.
    '''
    def __init__(self, prohibited_kwa_type):
        self.prohibited_kwa_type = prohibited_kwa_type
        self.origin = "granted"

    def __eq__(self, object):
        return (isinstance(object, KWAProhibition) and (self.prohibited_kwa_type == object.prohibited_kwa_type))

    def clone_for_new_host_object(self, new_host_object):
        return self.__class__(prohibited_kwa_type=self.prohibited_kwa_type)

    def __repr__(self):
        return "|CANT|{}|".format(self.prohibited_kwa_type)


class Prohibition:
    def __init__(self):
        pass

class Permission:
    def __init__(self):
        pass


class LandPlayPermission(Permission):
    '''\
        Example:
        Crucible of Worlds
            "You may play land cards from your graveyard."
    '''
    def __init__(self, source_zone_type):
        self.source_zone_type = source_zone_type


class LandPlayProhibition(Prohibition):
    '''\
        Example:
        Experimental Frenzy
            "You can't play cards from your hand."
    '''
    def __init__(self, source_zone_type):
        self.source_zone_type = source_zone_type


class AdditionalNLandPlayPermission(Permission):
    '''\
        Example:
        Azusa, Lost but Seeking
            "You may play two additional lands on each of your turns."
        Dryad of the Ilysian Grove
            "You may play an additional land on each of your turns."
    '''
    def __init__(self, N):
        self.N = N


#########################
# Specific KWA Examples #
#########################
class KWAFlying(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="flying", origin=origin)


class KWAFlash(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="flash", origin=origin)


class KWAIndestructible(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="indestructible", origin=origin)


class KWADeathtouch(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="deathtouch", origin=origin)


class KWATrample(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="trample", origin=origin)


class KWATrampleOverPlaneswalkers(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="trample over planeswalkers", origin=origin)


class KWAFirstStrike(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="first strike", origin=origin)


class KWADoubleStrike(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="double strike", origin=origin)


class KWAMenace(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="menace", origin=origin)


class KWAVigilance(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="vigilance", origin=origin)


class KWAReach(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="reach", origin=origin)


class KWALifelink(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="lifelink", origin=origin)


class KWAHexproof(KWA):
    # TODO # Expand for variants.
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="hexproof", origin=origin)


class KWAHaste(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="haste", origin=origin)


class KWAShroud(KWA):
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="shroud", origin=origin)


class KWAProtection(KWA):
    # TODO # Expand for variants.
    def __init__(self, host_object, origin="rules_text"):
        super().__init__(host_object=host_object, ability_name="protection", origin=origin)


#############################################################################################################
class ManaAbility:
    '''\
        Placeholder.
    '''
    def __init__(self, particles, origin="rules_text"):
        self.particles = particles
        self.origin = origin

    def __repr__(self):
        return "Tap: Add {}.".format(self.particles)

    def __eq__(self, object):
        if (self.__repr__() == object.__repr__()):
            return True
        return False


################################################
# Mana Abilities Intrinsic to Basic Land Types #
################################################
class PlainsManaAbility(ManaAbility):
    def __init__(self):
        super().__init__(particles="{W}")


class IslandManaAbility(ManaAbility):
    def __init__(self):
        super().__init__(particles="{U}")


class SwampManaAbility(ManaAbility):
    def __init__(self):
        super().__init__(particles="{B}")


class MountainManaAbility(ManaAbility):
    def __init__(self):
        super().__init__(particles="{R}")


class ForestManaAbility(ManaAbility):
    def __init__(self):
        super().__init__(particles="{G}")



################################################
# Deltas For Granting Intrinsic Mana Abilities #
################################################
class AddPlainsManaAbility(ReflexiveDelta):
    def __init__(self):
        super().__init__(reference_attributes=['abilities'],
                         arbitrary_function=IdempotentManaAbilityGrant(mana_ability_types_to_grant=[PlainsManaAbility]))


class AddIslandManaAbility(ReflexiveDelta):
    def __init__(self):
        super().__init__(reference_attributes=['abilities'],
                         arbitrary_function=IdempotentManaAbilityGrant(mana_ability_types_to_grant=[IslandManaAbility]))


class AddSwampManaAbility(ReflexiveDelta):
    def __init__(self):
        super().__init__(reference_attributes=['abilities'],
                         arbitrary_function=IdempotentManaAbilityGrant(mana_ability_types_to_grant=[SwampManaAbility]))


class AddMountainManaAbility(ReflexiveDelta):
    def __init__(self):
        super().__init__(reference_attributes=['abilities'],
                         arbitrary_function=IdempotentManaAbilityGrant(mana_ability_types_to_grant=[MountainManaAbility]))


class AddForestManaAbility(ReflexiveDelta):
    def __init__(self):
        super().__init__(reference_attributes=['abilities'],
                         arbitrary_function=IdempotentManaAbilityGrant(mana_ability_types_to_grant=[ForestManaAbility]))


def landtype_deltas_given_string(landtype_string):
    '''\
        Convenience function for producing the pair of deltas required by effect components
        which intend to add a basic land type to an object (addition of the intrinsic mana
        ability associated with that basic land type is implied).
    '''
    if (landtype_string == "plains"):
        return [AddLandTypePlains(), AddPlainsManaAbility()]
    elif (landtype_string == "island"):
        return [AddLandTypeIsland(), AddIslandManaAbility()]
    elif (landtype_string == "swamp"):
        return [AddLandTypeSwamp(), AddSwampManaAbility()]
    elif (landtype_string == "mountain"):
        return [AddLandTypeMountain(), AddMountainManaAbility()]
    elif (landtype_string == "forest"):
        return [AddLandTypeForest(), AddForestManaAbility()]
    else:
        raise ValueError("{} is not a valid landtype.".format(landtype_string))


def landtype_delta_factory(list_of_landtype_strings, in_addition=False):
    '''\
        For effect components which add to the landtypes of an object, or which
        set the landtypes of an object to a specific set of subtypes (which come with
        their respective intrinsic mana abilities). 305.6 states that when the landtypes
        aren't added in addition to the other landtypes of the object:
            all pre-existing landtypes;
            their associated intrinsic mana abilities;
            abilities derived from the object's rules text; and,
            abilities granted to the object by copiable effects must be removed.
        Abilities granted by other effects are not removed.
    '''
    deltas = [] if in_addition else [LoseAllLandTypes(), LoseNonGrantedAbilities()]
    for landtype_string in list_of_landtype_strings:
        deltas.extend(landtype_deltas_given_string(landtype_string))
    return deltas




class Marker:
    def __init__(self, host_object, effect_component):
        self.host_object = host_object
        self.effect_component = effect_component
        self.effect_component.reference_marker = self
        self.timestamp = TIMESTAMP()


###################################################################
# Markers Which Modify the Abilities Characteristic of Permanents #
###################################################################
class KeywordAbilityMarker(Marker):
    def __init__(self, host_object, kwa_type_to_add):
        super().__init__(host_object=host_object,
                         effect_component=MFXC(layer="6",
                                               external_deltas=[
                                                   AddKeywordAbilities(kwa_types_to_add=[kwa_type_to_add])
                                               ]))


class KWAFlyingMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWAFlying)


class KWAFirstStrikeMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWAFirstStrike)


class KWADoubleStrikeMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWADoubleStrike)


class KWADeathtouchMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWADeathtouch)


class KWAHasteMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWAHaste)


class KWAHexproofMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWAHexproof)


class KWAIndestructibleMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWAIndestructible)


class KWALifelinkMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWALifelink)


class KWAMenaceMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWAMenace)


class KWAReachMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWAReach)


class KWATrampleMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWATrample)


class KWAVigilanceMarker(KeywordAbilityMarker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object, kwa_type_to_add=KWAVigilance)


##############################################################
# Markers Which Modify the Power and Toughness of Permanents #
##############################################################
class PlusOnePlusOneMarker(Marker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object,
                         effect_component=MFXC(layer="7c",
                                               external_deltas=[
                                                   PowerDelta(amount=1, gain=True),
                                                   ToughnessDelta(amount=1, gain=True)
                                               ]))

class MinusOneMinusOneMarker(Marker):
    def __init__(self, host_object=None):
        super().__init__(host_object=host_object,
                         effect_component=MFXC(layer="7c",
                                               external_deltas=[
                                                   PowerDelta(amount=1, gain=False),
                                                   ToughnessDelta(amount=1, gain=False)
                                               ]))
