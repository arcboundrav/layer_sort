from object_config import *

# Example of Layer 4 Dependency Being Resolved

alpha_myr = AlphaMyr(controller=p0)
test_creature = TestCreature(controller=p0)
test_creature_ii = TestCreatureII(controller=p0)
test_land = TestLand(controller=p0)

# Scenario 1a #
# Alpha Myr, an artifact creature, enters the battlefield under p0's control.
ZH.zone_battlefield.add_object(alpha_myr)
snapshot()
display([alpha_myr])

# Scenario 1a Outcome #
# With nothing to affect it, Alpha Myr has its default characteristics.
assert alpha_myr.card_types == set(['creature', 'artifact'])

# Scenario 1b #
# Next, Test Land enters the battlefield under p0's control.
ZH.zone_battlefield.add_object(test_land)
snapshot()
display([test_land])

# Scenario 1b Outcome #
# With nothing to affect it, Test Land has its default characteristics as well.
assert test_land.card_types == set(['land'])

# Scenario 1c #
# Test Creature enters the battlefield under p0's control.
# Test Creature's only card type is creature.
# Test Creature has a static ability which generates a continuous effect which modifies a
# characteristic of game objects, namely, type. It reads, "All lands are artifacts in
# addition to their other types."
ZH.zone_battlefield.add_object(test_creature)
snapshot()
display([alpha_myr, test_land, test_creature])

# Scenario 1c Outcome #
# Alpha Myr and Test Creature do not get affected by the continuous effect generated by
# Test Creature's static ability. However, Test Land, which is a land, gains the artifact
# card type.
assert alpha_myr.card_types == set(['creature', 'artifact'])
assert test_land.card_types == set(['land', 'artifact'])
assert test_creature.card_types == set(['creature'])

# Scenario 1d #
# Finally, Test Creature II enters the battlefield under p0's control.
# Test Creature II's only card type is creature.
# Test Creature II has a static ability which generates a continuous effect which modifies
# the type characteristic of game objects. It reads, "All artifacts are enchantments in
# addition to their other types."
ZH.zone_battlefield.add_object(test_creature_ii)
snapshot()
display([alpha_myr, test_land, test_creature, test_creature_ii])

# Scenario 1d Outcome #
# Test Creature and Test Creature II are unaffected by any continuous effects.
# Alpha Myr, an artifact creature by default, gains the enchantment card type due to
# Test Creature II's ability. Test Land, a land by default, gained the artifact card type
# due to Test Creature's ability. This effect has an earlier timestamp, so by the time the
# effect generated from Test Creature II's ability goes to be applied, it sees Test Land as
# an artifact land. Therefore, Test Land gains the enchantment card type as well.
assert alpha_myr.card_types == set(['creature', 'artifact', 'enchantment'])
assert test_land.card_types == set(['land', 'artifact', 'enchantment'])


# Scenario 2 #
# Scenario 2 differs from Scenario 1 by changing the order in which Test Creature and Test
# Creature II enter the battlefield. This will give the effect generated by Test Creature's
# ability a later timestamp than the timestamp of the effect generated by Test Creature II's
# ability. The effects apply in the same layer (4); and, neither are characteristic defining
# abilities. The set of objects that the effect from Test Creature II's ability should affect
# changes depending on whether or not the effect from Test Creature's ability is applied before
# or afterward. If Test Creature II's ability is applied first, Test Land won't have become an
# artifact land due to Test Creature's ability. Therefore, it will not gain the enchantment card
# type, in contrast to the Scenario 1d Outcome. On the other hand, Test Creature's ability will
# generate an effect that maintains its impact on the state regardless of whether or not
# the effect generated by Test Creature II's ability is applied first.
# For these reasons, the system should detect a one-way dependency between the two effects---
# Test Creature II's effect depends on Test Creature's effect---and over-ride the timestamp system.
# The Scenario 2 Outcome should therefore match the Scenario 1d Outcome, even though Test Creature
# and Test Creature II's timestamps will be reversed.

ZH.zone_battlefield.remove_specific_object_(test_creature)
ZH.zone_battlefield.remove_specific_object_(test_creature_ii)

snapshot()
display([alpha_myr, test_land])

# With Test Creature and Test Creature II off of the battlefield, Alpha Myr and Test Land revert
# to displaying their default characteristics.
assert alpha_myr.card_types == set(['creature', 'artifact'])
assert test_land.card_types == set(['land'])


# Test Creature II enters the battlefield under p0's control.
# This should cause Alpha Myr to gain the enchantment card type, without impacting Test Land.
ZH.zone_battlefield.add_object(test_creature_ii)

snapshot()
display([alpha_myr, test_land])

assert alpha_myr.card_types == set(['creature', 'artifact', 'enchantment'])
assert test_land.card_types == set(['land'])

# Test Creature enters the battlefield under p0's control.
# If only timestamp order mattered, then the only consequence would be Test Land gaining
# the artifact card type. However, due to detecting the dependency, timestamp order should
# be over-ridden, and Test Land should gain both the artifact and enchantment card types.

ZH.zone_battlefield.add_object(test_creature)

snapshot()
display([alpha_myr, test_land])

assert alpha_myr.card_types == set(['creature', 'artifact', 'enchantment'])
assert test_land.card_types == set(['land', 'artifact', 'enchantment'])
